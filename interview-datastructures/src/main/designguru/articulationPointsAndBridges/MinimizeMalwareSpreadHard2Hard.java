package designguru.articulationPointsAndBridges;

public class MinimizeMalwareSpreadHard2Hard {
    // Helper method to perform DFS using Tarjan's algorithm
    private int dfs(int[][] graph, int currentNode, int parent, int currentTime, int[] discoveryTime, int[] lowestTime, boolean[] isInfected, int[] malwareSpreadCount) {
        // Initialize discovery and lowest reachable time for the current node
        lowestTime[currentNode] = discoveryTime[currentNode] = currentTime;
        boolean isMalwareSpread = isInfected[currentNode];
        int componentSize = 1; // Initialize component size

        // Traverse all connected nodes
        for (int neighbor = 0; neighbor < graph[currentNode].length; neighbor++) {
            if (graph[currentNode][neighbor] == 1) { // Check if there is a connection
                if (discoveryTime[neighbor] == 0) { // If the neighbor has not been visited
                    int subTreeSize = dfs(graph, neighbor, currentNode, currentTime + 1, discoveryTime, lowestTime, isInfected, malwareSpreadCount);
                    if (subTreeSize == 0) { // If subtree contains a malware node
                        isMalwareSpread = true;
                    } else {
                        componentSize += subTreeSize; // Add subtree size to the current component size
                    }
                    // Update malware spread count if the lowest time of the neighbor is greater than or equal to the discovery time
                    if (lowestTime[neighbor] >= discoveryTime[currentNode]) {
                        malwareSpreadCount[currentNode] += subTreeSize;
                    }
                    lowestTime[currentNode] = Math.min(lowestTime[currentNode], lowestTime[neighbor]); // Update lowest reachable time
                } else if (neighbor != parent) { // If the neighbor is not the parent, update the lowest reachable time
                    lowestTime[currentNode] = Math.min(lowestTime[currentNode], discoveryTime[neighbor]);
                }
            }
        }
        return isMalwareSpread ? 0 : componentSize; // Return the size of the component if malware doesn't spread
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int numNodes = graph.length; // Number of nodes in the graph
        int nodeToRemove = initial[0]; // Start with the first node in the initial array
        int maxSavedNodes = 0; // Maximum number of saved nodes

        boolean[] isInfected = new boolean[numNodes];
        for (int node : initial) isInfected[node] = true; // Mark initially infected nodes

        int[] discoveryTime = new int[numNodes];
        int[] lowestTime = new int[numNodes];
        int[] malwareSpreadCount = new int[numNodes];

        // Perform DFS for each initially infected node
        for (int node : initial) {
            if (discoveryTime[node] == 0) {
                dfs(graph, node, -1, 1, discoveryTime, lowestTime, isInfected, malwareSpreadCount);
            }
            // Choose the node that maximizes the number of saved nodes
            if (malwareSpreadCount[node] > maxSavedNodes || (malwareSpreadCount[node] == maxSavedNodes && node < nodeToRemove)) {
                maxSavedNodes = malwareSpreadCount[node];
                nodeToRemove = node;
            }
        }
        return nodeToRemove;
    }

    // Main method for testing
    public static void main(String[] args) {
        MinimizeMalwareSpreadHard2Hard solution = new MinimizeMalwareSpreadHard2Hard();

        int[][] graph1 = {
                {1, 0, 1},
                {0, 1, 1},
                {1, 1, 1}
        };
        int[] initial1 = {0, 2};
        System.out.println("Result for Example 1: " + solution.minMalwareSpread(graph1, initial1));

        int[][] graph2 = {
                {1, 1, 0, 0},
                {1, 1, 0, 0},
                {0, 0, 1, 1},
                {0, 0, 1, 1}
        };
        int[] initial2 = {1, 2};
        System.out.println("Result for Example 2: " + solution.minMalwareSpread(graph2, initial2));

        int[][] graph3 = {
                {1, 0, 0, 1},
                {0, 1, 1, 0},
                {0, 1, 1, 1},
                {1, 0, 1, 1}
        };
        int[] initial3 = {0, 2};
        System.out.println("Result for Example 3: " + solution.minMalwareSpread(graph3, initial3));
    }
}
