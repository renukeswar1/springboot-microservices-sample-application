package designguru.articulationPointsAndBridges;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class MinimizeMalwareSpreadHard {
    private int time = 0;

    public int minimizeMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] discovery = new int[n]; // Time of discovery of nodes
        int[] low = new int[n]; // Lowest point that can be reached
        int[] parent = new int[n]; // Parent of nodes in DFS
        boolean[] inStack = new boolean[n]; // To check if a node is in the stack
        Stack<Integer> stack = new Stack<>();
        Arrays.fill(discovery, -1);
        Arrays.fill(low, -1);
        Arrays.fill(parent, -1);

        List<List<Integer>> scc = new ArrayList<>(); // List to hold all SCCs

        // Tarjan's algorithm to find SCCs
        for (int i = 0; i < n; i++) {
            if (discovery[i] == -1) {
                tarjanSCC(i, graph, discovery, low, parent, inStack, stack, scc);
            }
        }

        int[] infectedCount = new int[scc.size()];
        int[] componentSize = new int[scc.size()];
        int[] componentMap = new int[n];

        // Map nodes to their SCC and count the size of each SCC
        for (int i = 0; i < scc.size(); i++) {
            for (int node : scc.get(i)) {
                componentMap[node] = i;
                componentSize[i]++;
            }
        }

        // Count infected nodes in each SCC
        for (int node : initial) {
            int comp = componentMap[node];
            infectedCount[comp]++;
        }

        Arrays.sort(initial);
        int result = initial[0];
        int maxSavedNodes = -1;

        // Determine the best node to remove
        for (int node : initial) {
            int comp = componentMap[node];
            if (infectedCount[comp] == 1) { // Only one malware node in this SCC
                if (componentSize[comp] > maxSavedNodes) {
                    maxSavedNodes = componentSize[comp];
                    result = node;
                }
            }
        }

        return result;
    }

    private void tarjanSCC(int u, int[][] graph, int[] discovery, int[] low, int[] parent, boolean[] inStack, Stack<Integer> stack, List<List<Integer>> scc) {
        discovery[u] = low[u] = time++;
        stack.push(u);
        inStack[u] = true;

        for (int v = 0; v < graph.length; v++) {
            if (graph[u][v] == 1 && u != v) { // There's an edge from u to v
                if (discovery[v] == -1) { // If v is not visited
                    parent[v] = u;
                    tarjanSCC(v, graph, discovery, low, parent, inStack, stack, scc);

                    low[u] = Math.min(low[u], low[v]); // Update the low-link value of u
                } else if (inStack[v]) { // Back edge found
                    low[u] = Math.min(low[u], discovery[v]); // Update the low-link value of u
                }
            }
        }

        // If u is a root node, pop the stack and form an SCC
        if (low[u] == discovery[u]) {
            List<Integer> currentSCC = new ArrayList<>();
            while (true) {
                int v = stack.pop();
                inStack[v] = false;
                currentSCC.add(v);
                if (v == u) break;
            }
            scc.add(currentSCC);
        }
    }

    public static void main(String[] args) {
        MinimizeMalwareSpreadHard sol = new MinimizeMalwareSpreadHard();

        int[][] graph1 = {{1, 0, 0}, {0, 1, 1}, {0, 1, 1}};
        int[] initial1 = {0, 1};
        System.out.println(sol.minimizeMalwareSpread(graph1, initial1)); // Output: 1

        int[][] graph2 = {{1, 1, 0, 0}, {1, 1, 0, 0}, {0, 0, 1, 1}, {0, 0, 1, 1}};
        int[] initial2 = {1, 2};
        System.out.println(sol.minimizeMalwareSpread(graph2, initial2)); // Output: 1


        int[][] graph3 = {{1, 0, 0, 1}, {0, 1, 1, 0}, {0, 1, 1, 1}, {1, 0, 1, 1}};
        int[] initial3 = {0, 2};
        System.out.println(sol.minimizeMalwareSpread(graph3, initial3)); // Output: 0
    }
}
